
<!--
Dike - Route Success Calculator and Inflator
https://github.com/alperakcan/dike

This is free and unencumbered software released into the public domain.
For more information, see: https://unlicense.org/

Third-party libraries:
- Clipper2 (Boost Software License)
- Expat XML Parser (MIT License)
- RapidJSON (MIT License)
- zip library (MIT License)
- Bootstrap (MIT License)
- Bootstrap Icons (MIT License)
- jQuery (MIT License)

Full license information: https://github.com/alperakcan/dike/blob/main/LICENSE
-->

<html>
        <head>
                <title>Dike : Route Success Calculator</title>
                <meta charset="utf-8">
                <meta name="viewport" content="width=device-width, initial-scale=1">
                <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">
                <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">
                <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
                <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js" integrity="sha384-IQsoLXl5PILFhosVNubq5LC7Qb9DXgDA9i+tQ8Zj3iwWAwPtgFTxbJ8NT4GN1R8p" crossorigin="anonymous"></script>
                <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.min.js" integrity="sha384-cuYeSxntonz0PPNlHhBs68uyIAVpIIOZZ5JqeqvYYIcEL727kskC66kF92t6Xl2V" crossorigin="anonymous"></script>
                </head>

        <body id="body">
                <script type="module">
                        import DikeWasm from "./DikeWasmES6.js";

                        let dikeModule  = null;
                        let dikeInstance= null;

                        let dikeTracks  = new Array();
                        let dikeRecords = new Array();

                        function init () {
                                (async () => {
                                        await DikeWasm().then(function(Module) {
                                                console.log("dikeModuleES6 loaded");
                                                dikeModule = Module;
                                                var timePrev = (new Date()).getTime();
                                                dikeInstance = dikeModule._calculateCreate();
                                                dikeModule._calculateReset(dikeInstance);
                                                var timeThen = (new Date()).getTime();
                                                var timeElapsed = timeThen - timePrev;
                                                outputDike.innerHTML = "initialized in " + timeElapsed + "ms <br>";
                                                outputDike.innerHTML += "Waiting for calculation...<br>";
                                        });
                                })();
                        }

                        function stringToUTF8Array (str) {
                                var utf8 = [];
                                for (var i = 0; i < str.length; i++) {
                                        var charcode = str.charCodeAt(i);
                                        if (charcode < 0x80) {
                                                utf8.push(charcode);
                                        } else if (charcode < 0x800) {
                                                utf8.push(0xc0 | (charcode >> 6),
                                                          0x80 | (charcode & 0x3f));
                                        } else if (charcode < 0xd800 || charcode >= 0xe000) {
                                                utf8.push(0xe0 | (charcode >> 12),
                                                          0x80 | ((charcode >> 6) & 0x3f),
                                                          0x80 | (charcode & 0x3f));
                                        } else {
                                                i++;
                                                charcode = ((charcode&0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff) + 0x010000;
                                                utf8.push(0xf0 | (charcode >>18),
                                                          0x80 | ((charcode >> 12) & 0x3f),
                                                          0x80 | ((charcode >> 6) & 0x3f),
                                                          0x80 | (charcode & 0x3f));
                                        }
                                }
                                utf8.push(0x00);
                                return utf8;
                        }

                        let stringFromUtf8 = function (data) {
                                var str = "";
                                var i;
                                for (i = 0; i < data.length; i++) {
                                        var value = data[i];

                                        if (value == 0) {
                                                break;
                                        } else if (value < 0x80) {
                                                str += String.fromCharCode(value);
                                        } else if (value > 0xBF && value < 0xE0) {
                                                str += String.fromCharCode((value & 0x1F) << 6 | data[i + 1] & 0x3F);
                                                i += 1;
                                        } else if (value > 0xDF && value < 0xF0) {
                                                str += String.fromCharCode((value & 0x0F) << 12 | (data[i + 1] & 0x3F) << 6 | data[i + 2] & 0x3F);
                                                i += 2;
                                        } else {
                                                var charCode = ((value & 0x07) << 18 | (data[i + 1] & 0x3F) << 12 | (data[i + 2] & 0x3F) << 6 | data[i + 3] & 0x3F) - 0x010000;
                                                str += String.fromCharCode(charCode >> 10 | 0xD800, charCode & 0x03FF | 0xDC00);
                                                i += 3;
                                        }
                                }
                                return str;
                        }

                        function renderCalculationView(acceptedPathPtr, rejectedPathPtr) {
                                const container = document.getElementById("outputView");
                                const width = container.clientWidth || 800;
                                const height = 420;
                                const margin = 20;

                                function collectSubpaths(pathPtr) {
                                        if (!pathPtr) return [];
                                        const n = dikeModule._pathGetPointsCount(pathPtr);
                                        if (n <= 0) return [];
                                        let subpaths = [];
                                        let current = [];
                                        for (let i = 0; i < n; i++) {
                                                const pt = dikeModule._pathGetPoint(pathPtr, i);
                                                if (pt === 0) continue;
                                                const cmd = dikeModule._pathGetPointCommand(pt);
                                                const lat = dikeModule._pathGetPointLat(pt);
                                                const lon = dikeModule._pathGetPointLon(pt);
                                                if (cmd === 1 /* MoveTo */) {
                                                        if (current.length > 0) subpaths.push(current);
                                                        current = [];
                                                }
                                                current.push([lon, lat]);
                                        }
                                        if (current.length > 0) subpaths.push(current);
                                        return subpaths;
                                }

                                const accSubs = collectSubpaths(acceptedPathPtr);
                                const rejSubs = collectSubpaths(rejectedPathPtr);

                                let minLon = Infinity, maxLon = -Infinity, minLat = Infinity, maxLat = -Infinity;
                                const allSubs = accSubs.concat(rejSubs);
                                for (const sub of allSubs) {
                                        for (const [lon, lat] of sub) {
                                                if (lon < minLon) minLon = lon;
                                                if (lon > maxLon) maxLon = lon;
                                                if (lat < minLat) minLat = lat;
                                                if (lat > maxLat) maxLat = lat;
                                        }
                                }

                                if (!isFinite(minLon) || !isFinite(maxLon) || !isFinite(minLat) || !isFinite(maxLat)) {
                                        container.innerHTML = '<div class="text-muted">No geometry to display.</div>';
                                        return;
                                }

                                const lonSpan = (maxLon - minLon) || 1e-6;
                                const latSpan = (maxLat - minLat) || 1e-6;

                                let viewBox = {
                                        x: 0,
                                        y: 0,
                                        width: width,
                                        height: height
                                };
                                let isPanning = false;
                                let startPoint = { x: 0, y: 0 };

                                function project(lon, lat) {
                                        const x = margin + (lon - minLon) * (width - 2 * margin) / lonSpan;
                                        const y = height - margin - (lat - minLat) * (height - 2 * margin) / latSpan;
                                        return [x, y];
                                }

                                function pathData(sub) {
                                        if (sub.length === 0) return "";
                                        const [x0, y0] = project(sub[0][0], sub[0][1]);
                                        let d = `M ${x0.toFixed(2)},${y0.toFixed(2)}`;
                                        for (let i = 1; i < sub.length; i++) {
                                                const [x, y] = project(sub[i][0], sub[i][1]);
                                                d += ` L ${x.toFixed(2)},${y.toFixed(2)}`;
                                        }
                                        return d;
                                }

                                function render() {
                                        let svgParts = [];
                                        svgParts.push(`<svg id="calcSvg" xmlns="http://www.w3.org/2000/svg" width="100%" height="${height}" viewBox="${viewBox.x} ${viewBox.y} ${viewBox.width} ${viewBox.height}" style="cursor: grab;">`);
                                        svgParts.push(`<rect x="0" y="0" width="${width}" height="${height}" fill="#ffffff"/>`);

                                        for (const sub of rejSubs) {
                                                const d = pathData(sub);
                                                if (d) svgParts.push(`<path d="${d}" fill="none" stroke="#dc3545" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" vector-effect="non-scaling-stroke" />`);
                                        }
                                        for (const sub of accSubs) {
                                                const d = pathData(sub);
                                                if (d) svgParts.push(`<path d="${d}" fill="none" stroke="#0d6efd" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" vector-effect="non-scaling-stroke" />`);
                                        }

                                        svgParts.push(`</svg>`);

                                        svgParts.push(`
                                                <div style="position: absolute; top: 10px; left: 10px; pointer-events: none; z-index: 10;">
                                                        <div style="background: rgba(248,249,250,0.95); border: 1px solid #dee2e6; border-radius: 6px; padding: 8px 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; font-size: 12px;">
                                                                <div style="display: flex; align-items: center; margin-bottom: 4px;">
                                                                        <div style="width: 30px; height: 3px; background: #0d6efd; margin-right: 8px;"></div>
                                                                        <span style="color: #212529;">Accepted</span>
                                                                </div>
                                                                <div style="display: flex; align-items: center;">
                                                                        <div style="width: 30px; height: 3px; background: #dc3545; margin-right: 8px;"></div>
                                                                        <span style="color: #212529;">Rejected</span>
                                                                </div>
                                                        </div>
                                                </div>
                                                <div style="position: absolute; top: 10px; right: 10px; display: flex; flex-direction: column; gap: 5px; z-index: 10;">
                                                        <button id="zoomIn" class="btn btn-sm btn-light shadow-sm" style="width: 36px; height: 36px;" title="Zoom In">
                                                                <i class="bi bi-zoom-in"></i>
                                                        </button>
                                                        <button id="zoomOut" class="btn btn-sm btn-light shadow-sm" style="width: 36px; height: 36px;" title="Zoom Out">
                                                                <i class="bi bi-zoom-out"></i>
                                                        </button>
                                                        <button id="zoomReset" class="btn btn-sm btn-light shadow-sm" style="width: 36px; height: 36px;" title="Reset View">
                                                                <i class="bi bi-arrow-clockwise"></i>
                                                        </button>
                                                </div>
                                        `);

                                        container.innerHTML = svgParts.join("");
                                        const svg = document.getElementById('calcSvg');

                                        svg.addEventListener('mousedown', (e) => {
                                                isPanning = true;
                                                svg.style.cursor = 'grabbing';
                                                startPoint = { x: e.clientX, y: e.clientY };
                                        });

                                        svg.addEventListener('mousemove', (e) => {
                                                if (!isPanning) return;
                                                const dx = (e.clientX - startPoint.x) * (viewBox.width / width);
                                                const dy = (e.clientY - startPoint.y) * (viewBox.height / height);

                                                let newX = viewBox.x - dx;
                                                let newY = viewBox.y - dy;

                                                newX = Math.max(0, Math.min(newX, width - viewBox.width));
                                                newY = Math.max(0, Math.min(newY, height - viewBox.height));

                                                viewBox.x = newX;
                                                viewBox.y = newY;
                                                startPoint = { x: e.clientX, y: e.clientY };
                                                render();
                                        });

                                        svg.addEventListener('mouseup', () => {
                                                isPanning = false;
                                                svg.style.cursor = 'grab';
                                        });

                                        svg.addEventListener('mouseleave', () => {
                                                isPanning = false;
                                                svg.style.cursor = 'grab';
                                        });

                                        svg.addEventListener('wheel', (e) => {
                                                e.preventDefault();
                                                const scale = e.deltaY < 0 ? 0.9 : 1.1;

                                                if (scale > 1 && (viewBox.width >= width || viewBox.height >= height)) {
                                                        return;
                                                }

                                                const rect = svg.getBoundingClientRect();
                                                const mouseX = e.clientX - rect.left;
                                                const mouseY = e.clientY - rect.top;
                                                const worldX = viewBox.x + (mouseX / rect.width) * viewBox.width;
                                                const worldY = viewBox.y + (mouseY / rect.height) * viewBox.height;

                                                viewBox.width *= scale;
                                                viewBox.height *= scale;
                                                viewBox.x = worldX - (mouseX / rect.width) * viewBox.width;
                                                viewBox.y = worldY - (mouseY / rect.height) * viewBox.height;

                                                viewBox.x = Math.max(0, Math.min(viewBox.x, width - viewBox.width));
                                                viewBox.y = Math.max(0, Math.min(viewBox.y, height - viewBox.height));

                                                render();
                                        });

                                        document.getElementById('zoomIn').addEventListener('click', () => {
                                                const scale = 0.8;
                                                const centerX = viewBox.x + viewBox.width / 2;
                                                const centerY = viewBox.y + viewBox.height / 2;
                                                viewBox.width *= scale;
                                                viewBox.height *= scale;
                                                viewBox.x = centerX - viewBox.width / 2;
                                                viewBox.y = centerY - viewBox.height / 2;

                                                viewBox.x = Math.max(0, Math.min(viewBox.x, width - viewBox.width));
                                                viewBox.y = Math.max(0, Math.min(viewBox.y, height - viewBox.height));

                                                render();
                                        });

                                        document.getElementById('zoomOut').addEventListener('click', () => {
                                                if (viewBox.width >= width || viewBox.height >= height) {
                                                        return;
                                                }

                                                const scale = 1.25;
                                                const centerX = viewBox.x + viewBox.width / 2;
                                                const centerY = viewBox.y + viewBox.height / 2;
                                                viewBox.width *= scale;
                                                viewBox.height *= scale;
                                                viewBox.x = centerX - viewBox.width / 2;
                                                viewBox.y = centerY - viewBox.height / 2;

                                                viewBox.x = Math.max(0, Math.min(viewBox.x, width - viewBox.width));
                                                viewBox.y = Math.max(0, Math.min(viewBox.y, height - viewBox.height));

                                                render();
                                        });

                                        document.getElementById('zoomReset').addEventListener('click', () => {
                                                viewBox = { x: 0, y: 0, width: width, height: height };
                                                render();
                                        });
                                }

                                render();
                        }

                        let inputDikeTrackDel = function (idx) {
                                dikeTracks.splice(idx, 1);

                                let innerHTML = "";

                                if (dikeTracks.length == 0) {
                                        innerHTML += "(empty)";
                                } else {
                                        innerHTML += ``;
                                        innerHTML += `<div>`;
                                        for (let i = 0; i < dikeTracks.length; i++) {
                                                innerHTML += `<p onclick="inputDikeTrackDel(${i});">${dikeTracks[i].name}</p>`;
                                        }
                                        innerHTML += `</div>`;
                                }

                                inputDikeTracksList.innerHTML = innerHTML;

                                dikeResult.innerHTML = "Add base tracks and route records, then kick 'Calculate'.";
                                outputView.innerHTML = "Waiting for calculation...<br>";
                                outputDike.innerHTML = "Waiting for calculation...<br>";
                        }

                        inputDikeTrackAdd.onclick = function (event) {
                                inputDikeTrackAddSelectFile.click();
                        }

                        inputDikeTrackAddSelectFile.onchange = function (event) {
                                for (let i = 0; i < event.target.files.length; i++) {
                                        let file = event.target.files[i];
                                        dikeTracks.push(file);
                                }

                                let innerHTML = "";

                                if (dikeTracks.length == 0) {
                                        innerHTML += "(empty)";
                                } else {
                                        innerHTML += ``;
                                        innerHTML += `<div>`;
                                        for (let i = 0; i < dikeTracks.length; i++) {
                                                innerHTML += `<p onclick="inputDikeTrackDel(${i});">${dikeTracks[i].name}</p>`;
                                        }
                                        innerHTML += `</div>`;
                                }

                                inputDikeTracksList.innerHTML = innerHTML;

                                dikeResult.innerHTML = "Add base tracks and route records, then kick 'Calculate'.";
                                outputView.innerHTML = "Waiting for calculation...<br>";
                                outputDike.innerHTML = "Waiting for calculation...<br>";
                        }

                        let inputDikeRecordDel = function (idx) {
                                dikeRecords.splice(idx, 1);

                                let innerHTML = "";

                                if (dikeRecords.length == 0) {
                                        innerHTML += "(empty)";
                                } else {
                                        innerHTML += ``;
                                        innerHTML += `<div>`;
                                        for (let i = 0; i < dikeRecords.length; i++) {
                                                innerHTML += `<p onclick="inputDikeRecordDel(${i});">${dikeRecords[i].name}</p>`;
                                        }
                                        innerHTML += `</div>`;
                                }

                                inputDikeRecordsList.innerHTML = innerHTML;

                                dikeResult.innerHTML = "Add base tracks and route records, then kick 'Calculate'.";
                                outputView.innerHTML = "Waiting for calculation...<br>";
                                outputDike.innerHTML = "Waiting for calculation...<br>";
                        }

                        inputDikeRecordAdd.onclick = function (event) {
                                inputDikeRecordAddSelectFile.click();
                        }

                        inputDikeRecordAddSelectFile.onchange = function (event) {
                                for (let i = 0; i < event.target.files.length; i++) {
                                        let file = event.target.files[i];
                                        dikeRecords.push(file);
                                }

                                let innerHTML = "";

                                if (dikeRecords.length == 0) {
                                        innerHTML += "(empty)";
                                } else {
                                        innerHTML += ``;
                                        innerHTML += `<div>`;
                                        for (let i = 0; i < dikeRecords.length; i++) {
                                                innerHTML += `<p onclick="inputDikeRecordDel(${i});">${dikeRecords[i].name}</p>`;
                                        }
                                        innerHTML += `</div>`;
                                }

                                inputDikeRecordsList.innerHTML = innerHTML;

                                dikeResult.innerHTML = "Add base tracks and route records, then kick 'Calculate'.";
                                outputView.innerHTML = "Waiting for calculation...<br>";
                                outputDike.innerHTML = "Waiting for calculation...<br>";
                        }

                        dikeCalculateButton.onclick = function (event) {
                                dikeModule._calculateReset(dikeInstance);

                                let load;
                                var timePrev = (new Date()).getTime();

                                let method         = document.getElementById("DikeCalculateMethod").value;
                                let coverageRadius = parseInt(document.getElementById("DikeCalculateMethodCoverageRadius").value);
                                let methodUTF8     = stringToUTF8Array(method);
                                let methodRaw      = dikeModule._malloc(methodUTF8.length);;
                                dikeModule.HEAPU8.set(methodUTF8, methodRaw);
                                dikeModule._calculateSetMethod(dikeInstance, methodRaw, coverageRadius);
                                dikeModule._free(methodRaw);

                                load = 0;

                                if (dikeTracks.length == 0 && dikeRecords.length == 0) {
                                        dikeResult.innerHTML = "Add base tracks and route records, then kick 'Calculate'.";
                                        outputDike.innerHTML = "No tracks or records to process.<br>";
                                        return;
                                }

                                dikeResult.innerHTML = "Calculating...";
                                window.scrollTo(0, 0);

                                outputDike.innerHTML = "loading tracks/records<br>";

                                for (let i = 0; i < dikeTracks.length; i++) {
                                        let file = dikeTracks[i];
                                        let fileReader = new FileReader();
                                        fileReader.onload = function (event) {
                                                let uint8Array = new Uint8Array(event.target.result);
                                                let raw = dikeModule._malloc(uint8Array.length);
                                                dikeModule.HEAPU8.set(uint8Array, raw);
                                                let rc = dikeModule._calculateAddTrack(dikeInstance, raw, uint8Array.length);
                                                if (rc != 0) {
                                                        outputDike.innerHTML += `can not load: ${dikeTracks[i].name}, rc: ${rc}<br>`;
                                                }
                                                dikeModule._free(raw);

                                                load += 1;
                                                if (load == dikeTracks.length + dikeRecords.length) {
                                                        var timeThen = (new Date()).getTime();
                                                        var timeElapsed = timeThen - timePrev;
                                                        outputDike.innerHTML += "loaded in " + timeElapsed + "ms <br>";

                                                        timePrev = (new Date()).getTime();
                                                        let calculateResult = dikeModule._calculateCalculate(dikeInstance);
                                                        let calculateMatchedPoints   = dikeModule.getValue(calculateResult + 0, 'i32');
                                                        let calculateTotalPoints     = dikeModule.getValue(calculateResult + 4, 'i32');
                                                        let calculateMatchedDistance = dikeModule.getValue(calculateResult + 8, 'double');
                                                        let calculateTotalDistance   = dikeModule.getValue(calculateResult + 16, 'double');
                                                        let calculateAcceptedPath    = dikeModule.getValue(calculateResult + 24, '*');
                                                        let calculateRejectedPath    = dikeModule.getValue(calculateResult + 28, '*');
                                                        timeThen = (new Date()).getTime();
                                                        timeElapsed = timeThen - timePrev;
                                                        outputDike.innerHTML += "calculated in " + timeElapsed + "ms <br>";

                                                        outputDike.innerHTML += `<p>`;
                                                        outputDike.innerHTML += `points  : ${(calculateMatchedPoints * 100 / calculateTotalPoints).toFixed(3)} (${calculateMatchedPoints} / ${calculateTotalPoints})<br>`;
                                                        outputDike.innerHTML += `distance: ${(calculateMatchedDistance * 100 / calculateTotalDistance).toFixed(3)} (${calculateMatchedDistance.toFixed(3)} / ${calculateTotalDistance.toFixed(3)})<br>`;
                                                        outputDike.innerHTML += `</p>`;

                                                        dikeResult.innerHTML = `% ${(calculateMatchedDistance * 100 / calculateTotalDistance).toFixed(3)} (${calculateMatchedDistance.toFixed(3)} / ${calculateTotalDistance.toFixed(3)})<br>`;

                                                        renderCalculationView(calculateAcceptedPath, calculateRejectedPath);

                                                        dikeModule._calculateResultFree(calculateResult);
                                                }
                                        }
                                        outputDike.innerHTML += `loading: ${dikeTracks[i].name}<br>`;
                                        fileReader.readAsArrayBuffer(file);
                                }

                                for (let i = 0; i < dikeRecords.length; i++) {
                                        let file = dikeRecords[i];
                                        let fileReader = new FileReader();
                                        fileReader.onload = function (event) {
                                                let uint8Array = new Uint8Array(event.target.result);
                                                let raw = dikeModule._malloc(uint8Array.length);
                                                dikeModule.HEAPU8.set(uint8Array, raw);
                                                let rc = dikeModule._calculateAddRecord(dikeInstance, raw, uint8Array.length);
                                                if (rc != 0) {
                                                        outputDike.innerHTML += `can not load: ${dikeRecords[i].name}, rc: ${rc}<br>`;
                                                }
                                                dikeModule._free(raw);

                                                load += 1;
                                                if (load == dikeTracks.length + dikeRecords.length) {
                                                        var timeThen = (new Date()).getTime();
                                                        var timeElapsed = timeThen - timePrev;
                                                        outputDike.innerHTML += "loaded in " + timeElapsed + "ms <br>";

                                                        timePrev = (new Date()).getTime();
                                                        let calculateResult = dikeModule._calculateCalculate(dikeInstance);
                                                        let calculateMatchedPoints   = dikeModule.getValue(calculateResult + 0, 'i32');
                                                        let calculateTotalPoints     = dikeModule.getValue(calculateResult + 4, 'i32');
                                                        let calculateMatchedDistance = dikeModule.getValue(calculateResult + 8, 'double');
                                                        let calculateTotalDistance   = dikeModule.getValue(calculateResult + 16, 'double');
                                                        let calculateAcceptedPath    = dikeModule.getValue(calculateResult + 24, '*');
                                                        let calculateRejectedPath    = dikeModule.getValue(calculateResult + 28, '*');
                                                        timeThen = (new Date()).getTime();
                                                        timeElapsed = timeThen - timePrev;
                                                        outputDike.innerHTML += "calculated in " + timeElapsed + "ms <br>";

                                                        outputDike.innerHTML += `<p>`;
                                                        outputDike.innerHTML += `points  : ${(calculateMatchedPoints * 100 / calculateTotalPoints).toFixed(3)} (${calculateMatchedPoints} / ${calculateTotalPoints})<br>`;
                                                        outputDike.innerHTML += `distance: ${(calculateMatchedDistance * 100 / calculateTotalDistance).toFixed(3)} (${calculateMatchedDistance.toFixed(3)} / ${calculateTotalDistance.toFixed(3)})<br>`;
                                                        outputDike.innerHTML += `</p>`;

                                                        dikeResult.innerHTML = `% ${(calculateMatchedDistance * 100 / calculateTotalDistance).toFixed(3)} (${calculateMatchedDistance.toFixed(3)} / ${calculateTotalDistance.toFixed(3)})<br>`;

                                                        console.log("Accepted Path Pointer: ", calculateAcceptedPath);
                                                        console.log("Rejected Path Pointer: ", calculateRejectedPath);

                                                        renderCalculationView(calculateAcceptedPath, calculateRejectedPath);
                                                        dikeModule._calculateResultFree(calculateResult);
                                                }
                                        }
                                        outputDike.innerHTML += `loading: ${dikeRecords[i].name}<br>`;
                                        fileReader.readAsArrayBuffer(file);
                                }
                        }

                        dikeResult.innerHTML = "Add base tracks and route records, then kick 'Calculate'.";
                        outputView.innerHTML = "Waiting for calculation...<br>";
                        outputDike.innerHTML = "Waiting for calculation...<br>";

                        inputDikeTracksList.innerHTML = "(empty)";
                        inputDikeRecordsList.innerHTML = "(empty)";

                        window.inputDikeTrackDel = inputDikeTrackDel;
                        window.inputDikeRecordDel = inputDikeRecordDel;

                        window.addEventListener("load", init, false);
                </script>
                <div class="container py-4">
                        <div class="row justify-content-center">
                                <div class="col-lg-10">
                                        <h1 class="text-center mb-4">
                                                <i class="bi bi-calculator"></i> Dike : Route Success Calculator
                                        </h1>

                                        <div id="dikeResult" class="alert alert-info text-center shadow-sm mb-4" role="alert">
                                                <i class="bi bi-info-circle"></i> Add base tracks and route records, then kick 'Calculate'.
                                        </div>

                                        <div class="row">
                                                <div class="col-md-6 mb-3">
                                                        <div class="card shadow-sm h-100">
                                                                <div class="card-body">
                                                                        <h5 class="card-title mb-3">
                                                                                <i class="bi bi-map"></i> Base Tracks
                                                                        </h5>
                                                                        <div id="inputDikeTracksList" class="mb-3 p-3 bg-light rounded" style="min-height: 100px;">
                                                                        </div>
                                                                        <button id="inputDikeTrackAdd" type="button" class="w-100 btn btn-outline-primary">
                                                                                <i class="bi bi-plus-circle"></i> Add Track
                                                                        </button>
                                                                        <input id="inputDikeTrackAddSelectFile" type="file" name="name" style="display: none;" multiple />
                                                                </div>
                                                        </div>
                                                </div>

                                                <div class="col-md-6 mb-3">
                                                        <div class="card shadow-sm h-100">
                                                                <div class="card-body">
                                                                        <h5 class="card-title mb-3">
                                                                                <i class="bi bi-geo-alt"></i> Route Records
                                                                        </h5>
                                                                        <div id="inputDikeRecordsList" class="mb-3 p-3 bg-light rounded" style="min-height: 100px;">
                                                                        </div>
                                                                        <button id="inputDikeRecordAdd" type="button" class="w-100 btn btn-outline-primary">
                                                                                <i class="bi bi-plus-circle"></i> Add Record
                                                                        </button>
                                                                        <input id="inputDikeRecordAddSelectFile" type="file" name="name" style="display: none;" multiple />
                                                                </div>
                                                        </div>
                                                </div>
                                        </div>

                                        <div class="card shadow-sm mb-4">
                                                <div class="card-body">
                                                        <h5 class="card-title mb-4">
                                                                <i class="bi bi-gear"></i> Calculation Settings
                                                        </h5>
                                                        <div class="row g-3 mb-3">
                                                                <div class="col-md-6">
                                                                        <label for="DikeCalculateMethod" class="form-label fw-bold">Calculation Method</label>
                                                                        <select id="DikeCalculateMethod" class="form-select">
                                                                                <option value="quadtree" selected>QuadTree (Recommended)</option>
                                                                                <option value="bruteforce" disabled>Brute Force (Too Slow)</option>
                                                                        </select>
                                                                        <small class="text-muted">QuadTree provides efficient spatial indexing for fast calculations</small>
                                                                </div>
                                                                <div class="col-md-6">
                                                                        <label for="DikeCalculateMethodCoverageRadius" class="form-label fw-bold">Coverage Radius (meters)</label>
                                                                        <input id="DikeCalculateMethodCoverageRadius" type="number" class="form-control" placeholder="Coverage Radius" value="250" min="1" />
                                                                        <small class="text-muted">Maximum distance to consider a point as matched</small>
                                                                </div>
                                                        </div>
                                                        <button id="dikeCalculateButton" type="button" class="w-100 btn btn-primary btn-lg">
                                                                <i class="bi bi-play-circle"></i> Calculate Success Rate
                                                        </button>
                                                </div>
                                        </div>
                                </div>
                        </div>
                </div>

                <div class="container py-3">
                        <div class="row justify-content-center">
                                <div class="col-lg-10">
                                        <div class="card shadow-sm">
                                                <div class="card-header bg-light">
                                                        <h5 class="mb-0"><i class="bi bi-terminal"></i> Calculation View</h5>
                                                </div>
                                                <div id="outputView" class="card-body font-monospace" style="position: relative; min-height: 100px; font-size: 0.9rem;">
                                                </div>
                                        </div>
                                </div>
                        </div>

                        <div class="row justify-content-center mt-3">
                                <div class="col-lg-10">
                                        <div class="card shadow-sm">
                                                <div class="card-header bg-light">
                                                        <h5 class="mb-0"><i class="bi bi-terminal"></i> Calculation Output</h5>
                                                </div>
                                                <div id="outputDike" class="card-body font-monospace" style="min-height: 100px; font-size: 0.9rem;">
                                                </div>
                                        </div>
                                </div>
                        </div>
                </div>

                <footer class="text-center py-4 mt-5 border-top bg-white">
                        <small class="text-muted">
                                <a href="/dike" class="text-decoration-none">Dike</a> is an open-source route suite for GPS tracks and records.<br>
                                Source code and documentation available at:
                                <a href="https://github.com/alperakcan/dike" target="_blank" class="text-decoration-none">
                                        <i class="bi bi-github"></i> github.com/alperakcan/dike
                                </a>
                        </small>
                </footer>
        </body>
</html>
